var j2;
module.exports = (function (j2) {

	const gulp = require('gulp');
	gulp.insert = require('gulp-insert');
	gulp.replace = require('gulp-replace');
	gulp.ts = require('gulp-typescript');

	const ts = require('typescript');

	const fs = require('fs');
	const del = require('del');
	const path = require('path');

	const merge = require('merge2');
	const through = require('through2');

	const browser_sync = require('browser-sync').create();

	const closure_compiler = require('google-closure-compiler').gulp();
	const closure_deps = require('google-closure-deps');

	const HEADER_STRICT = '"use strict";\n'
	const HEADER_STRING = `// Do not edit this file; automatically generated.\n`;
	const LICENSE_REGEX = /\/\*[\s\S]*?@license[\s\S]*?[Cc]opyright[\s\S]*?\*\/\s*/g

	/**
	 * Closure compiler warning groups used to treat warnings as errors.
	 * For a full list of closure compiler groups, consult:
	 * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/DiagnosticGroups.java#L113
	 */
	const JSCOMP_ERROR = [
		'accessControls',
		'checkPrototypalTypes',
		'checkRegExp',
		// 'checkTypes',
		'checkVars',
		'conformanceViolations',
		'const',
		'constantProperty',
		'deprecated',
		'deprecatedAnnotations',
		'duplicateMessage',
		'es5Strict',
		'externsValidation',
		'functionParams',
		'globalThis',
		'invalidCasts',
		'misplacedTypeAnnotation',
		'missingOverride',
		'missingPolyfill',
		'missingProperties',
		'missingProvide',
		// 'missingRequire',
		'missingReturn',
		// 'missingSourcesWarnings',
		'moduleLoad',
		'msgDescriptions',
		'nonStandardJsDocs',
		'partialAlias',
		'polymer',
		// 'reportUnknownTypes',
		'strictCheckTypes',
		'strictMissingProperties',
		'strictModuleDepCheck',
		'strictPrimitiveOperators',
		'suspiciousCode',
		'typeInvalidation',
		'undefinedNames',
		'undefinedVars',
		'underscore',
		'unknownDefines',
		// 'unusedLocalVariables',
		'unusedPrivateMembers',
		'uselessCode',
		'untranspilableFeatures',
		'visibility'
	];

	const DependencyProcessor = (function () {
		function DependencyProcessor() {
			this.dependencies = {};
		}

		DependencyProcessor.prototype.preprocess = function (changed_file, on_end) {
			const {
				dependencies
			} = this;
			return through.obj((file, _enc, cb) => {
				const file_path = path.relative(file.cwd, file.path);
				if (!changed_file || changed_file == file_path) {
					const result = closure_deps.parser.parseFile(file.path);
					for (const dep of result.dependencies) {
						// Set dep relative path
						dep.path = path.relative(file.cwd, dep.path);
						dependencies[file_path] = dep;
					}
				}
				on_end && on_end();
				cb(null);
			});
		};

		DependencyProcessor.prototype.generate_dependency = function (closure_path) {
			const {
				dependencies
			} = this;
			// Update the path to closure for any files that we don't know the full path
			// of (parsed from a goog.addDependency call).
			const deps = Object.values(dependencies);
			for (const dep of deps) {
				dep.setClosurePath(closure_path);
			}
			return closure_deps.depFile.getDepFileText(closure_path, deps).replace(/\\/g, '/');
		}

		return DependencyProcessor;

	}());

	const TypeScriptProcessor = (function () {
		function TypeScriptProcessor() {
			this.exports = {};
			this.provide = {};
			this.targets = {};
		}

		TypeScriptProcessor.prototype.preprocess = function (changed_file) {
			const {
				exports,
				provide
			} = this;
			return through.obj((file, _enc, cb) => {
				const file_path = path.relative(file.cwd, file.path);
				if (changed_file && changed_file != file_path) {
					cb(null, file);
					return;
				}

				const source = ts.createSourceFile(
					file_path,
					file.contents.toString(),
					ts.ScriptTarget.ES2015,
					/*setParentNodes */
					true
				);
				if (exports[file_path]) {
					for (const name of exports[file_path]) {
						provide[name] = false;
					}
					exports[file_path].length = 0;
				}

				function report(node, name) {
					const text = node.name.getText(source);
					name = name ? name + '.' + text : text;
					if (!provide[name]) {
						(exports[file_path] = exports[file_path] || []).push(name);
						provide[name] = true;
					}
					return name;
				}

				function visit(node, name) {
					const exported = is_node_exported(node);
					if (exported && name && ts.isClassDeclaration(node) && node.name) {
						report(node, name);
					} else if (exported && name && ts.isFunctionDeclaration(node) && node.name) {
						report(node, name);
					} else if (exported && name && ts.isVariableStatement(node)) {
						for (const vnode of node.declarationList.declarations) {
							report(vnode, name);
						}
					} else if (exported && ts.isModuleDeclaration(node)) {
						name = report(node, name);
						ts.forEachChild(node, (node) => {
							visit(node, name);
						});
					} else if (ts.isModuleBlock(node)) {
						ts.forEachChild(node, (node) => {
							visit(node, name);
						});
					}
				}
				ts.forEachChild(source, visit);
				cb(null, file);
			});
		};

		TypeScriptProcessor.prototype.generate_goog_provide = function (need_declare) {
			const {
				exports
			} = this;
			return gulp.insert.transform((contents, file) => {
				const file_path = path.relative(file.cwd, file.path).replace(/\.[^.]+$/, '.ts');
				const root_exports = {};
				for (const name of exports[file_path] || []) {
					const index = name.indexOf('.');
					root_exports[index >= 0 ? name.substr(0, index) : name] = true;
				}
				const header_declare = need_declare ? Object.keys(root_exports).map((name) => `/** @suppress {checkVars} */\nvar ${name} = ${name} || {};\n`).join('') : '';
				const header_provide = (exports[file_path] || []).map((name) => `goog.provide('${name}');\n`).join('');
				if (contents.startsWith(HEADER_STRICT)) {
					return HEADER_STRICT + HEADER_STRING + header_declare + header_provide + contents.substr(HEADER_STRICT.length);
				}
				return HEADER_STRING + header_declare + header_provide + contents;
			})
		}

		TypeScriptProcessor.prototype.record_targets = function () {
			const {
				targets
			} = this;
			return through.obj((file, _enc, cb) => {
				const ts_path = path.relative(file.cwd, file.history[0]).replace(/\.[^.]+$/, '.ts');
				const js_path = path.relative(file.cwd, file.path);
				targets[ts_path] = js_path;
				cb(null, file);
			});
		}

		return TypeScriptProcessor;

		function is_node_exported(node) {
			return (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Ambient) === 0 && ((ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) !== 0 || (!!node.parent && node.parent.kind === ts.SyntaxKind.SourceFile));
		}

	}());

	j2.DependencyProcessor = DependencyProcessor;
	j2.TypeScriptProcessor = TypeScriptProcessor;

	const Project = (function () {
		function Project(config) {
			Object.assign(this, config);
			if (typeof this.project == 'string' || !this.project) {
				this.project = gulp.ts.createProject(this.project || './tsconfig.json', {
					declaration: true
				});
			}
			if (typeof this.package == 'string' || !this.package) {
				this.package = require(this.package || path.resolve(process.cwd(), './package.json'));
			}

			this.js_srcs = this.js_srcs || [];

			this.package_name = this.package_name || this.package.name.replace(/\-+/g, '.');
			this.PACKAGE_NAME = this.PACKAGE_NAME || this.package_name.replace('\.', '_').toUpperCase();
			this.entry_point = this.entry_point || this.package_name;

			this.output_path = this.output_path || './js'
			this.closure_path = this.closure_path || './node_modules/google-closure-library/closure/goog';
			this.develop_path = this.develop_path || path.join(this.output_path, 'develop');
			this.develop_file = this.develop_file || path.join(this.output_path, `${this.package_name}.dev.js`);
			this.release_path = this.release_path || this.output_path;
			this.release_file = this.release_file || `${this.package_name}.js`;

			this.DEVELOP_FILE_HEAD = `
this.${this.PACKAGE_NAME}_ROOT = (function (root) {
  // Find name of root directory.
  var scripts = document.getElementsByTagName('script');
  var re = new RegExp('(.+)[\/]${this.develop_file.replace('\\', '/').replace(/^\.\//, '').replace('/', '\\/').replace('.', '\\.')}$');
  for (var i = 0, script; script = scripts[i]; i++) {
    var match = re.exec(script.src);
    if (match) {
      return match[1];
    }
  }
  alert('Could not detect root directory name.');
  return '';
})(this);

this.${this.PACKAGE_NAME}_BOOT = function (root) {

// Execute after Closure has loaded.
`;

			this.DEVELOP_FILE_TAIL = `
goog.require('${this.entry_point}')

delete root.${this.PACKAGE_NAME}_ROOT;
delete root.${this.PACKAGE_NAME}_BOOT;
};

document.write('<script src="' + this.${this.PACKAGE_NAME}_ROOT + '/${this.closure_path.replace('\\', '/').replace(/^\.\//, '')}/base.js"></script>');
document.write('<script>this.${this.PACKAGE_NAME}_BOOT(this);</script>');
`;

			this.compiler_config = Object.assign({
				compilation_level: 'ADVANCED',
				define: `${this.package_name}.VERSION='${this.package.version}'`,
				dependency_mode: 'PRUNE',
				entry_point: this.entry_point,
				externs: [],
				hide_warnings_for: [],
				js_output_file: this.release_file,
				jscomp_error: JSCOMP_ERROR,
				jscomp_off: ['checkTypes'],
				language_in: 'ECMASCRIPT_NEXT',
				language_out: 'ECMASCRIPT5_STRICT',
				rewrite_polyfills: false,
				warning_level: 'VERBOSE',
			}, this.release_config);
			this.compiler_extra_args = this.compiler_extra_args || {
				platform: ['native', 'java', 'javascript']
			};

			this.deps_proc = new DependencyProcessor();
			this.ts_proc = new TypeScriptProcessor();
		}

		Project.prototype.build_release = function (output_path) {
			const {
				project,
				ts_proc,
				closure_path,
				compiler_config,
				compiler_extra_args,
				release_path,
				js_srcs
			} = this;
			return function () {
				return merge(
						gulp.src(js_srcs.concat(`${closure_path}/**/*.js`))
						.pipe(gulp.replace(LICENSE_REGEX, '')),
						project.src()
						.pipe(ts_proc.preprocess())
						.pipe(project()).js
						.pipe(ts_proc.generate_goog_provide(true)))
					.pipe(closure_compiler(compiler_config, compiler_extra_args))
					.pipe(gulp.insert.prepend(HEADER_STRING))
					.pipe(gulp.dest(output_path || release_path));
			};
		};

		Project.prototype.build_develop = function (event, changed_file, stats, cb) {
			const {
				DEVELOP_FILE_HEAD,
				DEVELOP_FILE_TAIL,
				project,
				ts_proc,
				deps_proc,
				develop_path,
				develop_file,
				closure_path,
				js_srcs
			} = this;
			const output_dependencies = () => {
				const add_dependency = deps_proc.generate_dependency(closure_path);
				fs.writeFileSync(develop_file, HEADER_STRICT + HEADER_STRING + DEVELOP_FILE_HEAD + add_dependency + DEVELOP_FILE_TAIL);
				cb && cb()
			};
			return function () {
				if (!event) {
					if (fs.existsSync(develop_path)) {
						del.sync(develop_path);
					}
					return project.src()
						.pipe(ts_proc.preprocess())
						.pipe(project()).js
						.pipe(ts_proc.generate_goog_provide(false))
						.pipe(gulp.dest(develop_path))
						.pipe(ts_proc.record_targets())
						.pipe(deps_proc.preprocess())
						.pipe(gulp.src(js_srcs))
						.pipe(deps_proc.preprocess())
						.on('end', output_dependencies);
				} else if (event == 'unlink') {
					if (changed_file.endsWith('.ts')) {
						const js_path = ts_proc.targets[changed_file];
						if (js_path && fs.existsSync(js_path)) {
							del.sync(js_path);
						}
						delete deps_proc.dependencies[js_path];
						output_dependencies();
					} else if (changed_file.endsWith('.js')) {
						delete deps_proc.dependencies[changed_file];
						output_dependencies();
					}
				} else if (changed_file.endsWith('.ts')) {
					return project.src()
						.pipe(ts_proc.preprocess(changed_file))
						.pipe(project()).js
						.pipe(through.obj((file, _enc, cb) => {
							const file_path = path.relative(file.cwd, file.path).replace(/\.[^.]+$/, '.ts');
							if (changed_file != file_path) {
								cb(null);
							} else {
								cb(null, file);
							}
						}))
						.pipe(ts_proc.generate_goog_provide(false))
						.pipe(gulp.dest(develop_path))
						.pipe(ts_proc.record_targets())
						.pipe(deps_proc.preprocess(null, output_dependencies));
				} else if (changed_file.endsWith('.js')) {
					return gulp.src(js_srcs)
						.pipe(deps_proc.preprocess(changed_file, output_dependencies));
				}
			};
		}

		Project.prototype.watch_develop = function (port) {
			const watch_files = this.js_srcs.concat(this.project.config.include).concat(this.watch_files || []);
			const build_develop = this.build_develop.bind(this);
			return gulp.series(
				build_develop(),
				gulp.parallel(
					function () {
						browser_sync.init({
							server: {
								baseDir: './'
							},
							port: port || 80
						});
					},
					function () {
						gulp.watch(watch_files)
							.on('all', function (event, file, stats) {
								build_develop(event, file, stats, () => {
									browser_sync.reload();
								}).call();
							});
					}
				)
			);
		}

		return Project;
	}());

	j2.Project = Project;

	j2.copy = function (src, dst) {
		return () => gulp.src(src).pipe(gulp.dest(dst));
	};

	j2.transpile = function (project, config, js_output, dts_output) {
		if (typeof project == 'string' || !project) {
			project = gulp.ts.createProject(project || './tsconfig.json', config || {});
		}
		const result = project.src().pipe(project());
		return () => merge(
			result.js.pipe(gulp.dest(js_output)),
			result.dts.pipe(gulp.dest(dts_output || js_output)),
		);
	};

	return j2;
})(j2 || (j2 = {}));
